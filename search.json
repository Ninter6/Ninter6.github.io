[{"title":"从投影和观察矩阵提取视锥体","url":"/2024/03/02/%E4%BB%8E%E6%8A%95%E5%BD%B1%E5%92%8C%E8%A7%82%E5%AF%9F%E7%9F%A9%E9%98%B5%E6%8F%90%E5%8F%96%E8%A7%86%E9%94%A5%E4%BD%93/","content":"视锥体\n首先我不知道\"视锥体\"这个名字是否正确，但接下来我会使用这个称呼\n\n如图，视锥体是一个六面体。如果一个物体在视锥体内部，那么他就有可能显示在屏幕上。如果我们能够求出当前摄像机的视锥体，并对场景中所有物体的包围盒求交，那么我们就能过滤掉那些绝不可能显示在屏幕上的物体，从而达到减少渲染开支的目的。这其实就是可见性裁切(Visibility\nCulling)。\n想要进行上述操作，一个正确的在世界坐标下视锥体是必须的，如何求出这个视锥体，现在有两个方案:\n1. 根据相机投影矩阵参数生成，然后对原始视锥体进行变换\n2. 通过 projection-view 矩阵直接提取\n前者虽然简单，但是变换6个面还是有一点开销，所以我们选择后者，也就是本篇文章讨论的内容。\n平面方程\n先让我们回顾一下平面方程:\n\n其中平面的法向量其实就是(A, B, C)，即:\n\n而D可以视作原点到平面的距离。相信大家能看出，等式左边其实就是计算一个点到平面的距离，那我们不妨定义一个距离函数:\n\n当函数值为0时，那就意味着点P在平面上。\n\n注意: 本文接下来会直接用距离函数来表示一个平面\n\n提取视锥体\n假设有一个矩阵，时投影(projection)和观察(view)矩阵的乘积\n\n我们将一个点与之相乘\n\n接下来就会被变换到剪裁空间(Clip\nSpace)，如果对其进行透视除法(即: )，就可以将其转换到NDC(Normalized Device\nCoordinates)\n\n\n剪裁空间和NDC以vulkan中为例，下文计算也以此为准\n\n我们直接看剪裁空间的，如果可见，那么其一定满足如下条件:\n\n让我们关注的情况，先用替换，也如此\n\n只看 \n，我们不难发现这就能表示一个平面:\n\n但是我们需要平面的法向量是单位向量的，所以还需要归一化:\n\n我们用归一化后的来表示这个平面:\n\n\n注意：这里是两个四维向量相乘，平面方程的四个系数其实就是的四个分量\n\n这时只有点P在平面上方时，P才可能可见。\n对于  ，我们也如法炮制:\n\n同样也用一个平面来表示:\n\n依然只有点P在平面上方时，P才可能可见。\n我们不难举一反三写出所有六个面的方程:\n\n\n注意vulkan中NDC顶部是-1\n\n实现代码\n最后附上可能的c++实现代码。\nstd::array&lt;vec4, 6&gt; CreateViewingFrustumFromMatrix(const mat4&amp; mat, float x_left, float x_right, float y_top, float y_bottom, float z_near, float z_far) {    std::array&lt;vec4, 6&gt; f;    auto&amp; plane_right   = f[0];    auto&amp; plane_left    = f[1];    auto&amp; plane_top     = f[2];    auto&amp; plane_bottom  = f[3];    auto&amp; plane_near    = f[4];    auto&amp; plane_far     = f[5];#define NORMALIZE(x) do { \\    float rlen = 1.f / std::sqrtf(vec3(x).length_squared()); \\    x *= rlen; \\} while(0)    auto mat_column = mat.transposed();        plane_right = mat_column[3] * x_right - mat_column[0];    NORMALIZE(plane_right);    plane_left = mat_column[0] - mat_column[3] * x_left;    NORMALIZE(plane_left);    plane_top = mat_column[3] * y_top - mat_column[1];    NORMALIZE(plane_top);    plane_bottom = mat_column[1] - mat_column[3] * y_bottom;    NORMALIZE(plane_bottom);    plane_near = mat_column[2] - mat_column[3] * z_near;    NORMALIZE(plane_near);    plane_far = mat_column[3] * z_far - mat_column[2];    NORMALIZE(plane_far);    return f;    #undef NORMALIZE}\n引用\nFast\nExtraction of Viewing Frustum Planes from the WorldView -\nProjectionMatrix\n","categories":["Computer Graphics"],"tags":["Note"]},{"title":"Viewing world at 60Hz","url":"/2024/02/24/Viewing-world-at-60Hz/","content":"Introduction\n首先简单说一下这个博客的名字，Viewing world at\n60Hz(60Hz看世界)\n为啥叫这个名呢\n你想，宇宙运转的那么快，上帝拥有几乎无限的算力，世界反应一帧可以说不用时间\n而人类呢，反应迟钝，一秒顶多思考60次\n但尽管如此，宇宙那神秘的面纱在人类面前仍然触手可及\n那么，这篇博客的用意也很明显\n用这个时代给予的特权，用仅仅60Hz思维频率\n观察宇宙，了解宇宙，感受宇宙\n\n宇宙最不可理解之处，就在于它是可理解的 --Albert Einstein\n\nWhat can I say\n不管怎么说，这总归是一个学术博客，我会在这发布一些学术文章\n可能包含:\n- C++\n- Computer Graphics\n- ... // I haven't decided yet.\n可能会开放一个图书角，放一些相关书籍\n\n个人发电，不定时更新\n\n不善言辞，就不多说了，也不想就第一篇文章，还要改好几次\nTo Be Continued\n最后放一张图片，是别人为我做的，随便放的没有什么别的意思\n","categories":["Useless"],"tags":["null"]},{"title":"二叉树浅谈","url":"/2024/03/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B5%85%E8%B0%88/","content":"前言\n这几天突发奇想研究了一下二叉树，发现这东西确实有些能讲的。这篇算是一个笔记，也算记录一下自己的一些疑惑。\n树绝对是一种非常常用的数据结构，但c++stl并没有提供现成的容器，每次都需要自己实现。所以这篇文章也会记录一下，我在实践中遇到的问题。\n树\n树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n它具有以下的特点:\n- 每个节点有零个或多个子节点；\n- 没有父节点的节点称为根节点；\n- 每一个非根节点有且只有一个父节点；\n-\n除了根节点外，每个子节点可以分为多个不相交的子树(Subtree)\n补充性质:\n- 根节点到达每个节点的路径是唯一的\n\n树的概念不再过多赘述，更多信息请看引用，这里再强调一些重点:\n- 度: 子节点的个数\n- 深度: 根到此节点的经过的连接数\n- 树的高度: 最大深度+1\n- 根节点: 没有父亲的节点\n- 中间节点: 有父亲有孩子的节点\n- 叶子节点: 没有孩子的节点\n二叉树\n二叉树(Binary Tree)最直接的定义: 度为2的树\n二叉树作为一种特殊的树，拥有树的所有性质。\n特殊的二叉树\n空二叉树(Empty Binary Tree)\n没有节点的二叉树。空二叉树的高度是0。\n满二叉树(Full Binary Tree)\n除了叶子节点都有两个孩子。任一节点的子树都是满二叉树。\n只有根节点或着空二叉树也是满二叉树。\n性质:\n- 如果层序遍历这棵树，那么n号节点的两个孩子必然是(2n+1)和(2n+2)\n- 高度为k的满二叉树共有(2^k-1)个节点\n完全二叉树(Completed Binary\nTree)\n一棵深度为k的有n个结点的二叉树，按层序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。\n完全二叉树由于其特殊的性质，所以可以直接存储在数组中。stl中的std::make_heap也是这个原理。\n平衡二叉树(Balanced Binary\nTree)\n任一节点子树的深度差不超过1。\n平衡二叉树可以提高搜索效率。\n完全二叉树是平衡二叉树。\n二叉搜索树(Binary Search\nTree)\n二叉搜索树中每个节点都满足以下性质:\n- 所有左子树的节点的值都小于该节点的值；\n- 所有右子树的节点的值都大于该节点的值。\n二叉树的遍历\n前序遍历(Preorder Traversal)\n是一种深度优先遍历方法，会从根节点开始，然后遍历左子树，其次右子树。即遵循\"根-左-右\"原则。\n中序遍历(Inorder Traversal)\n首先递归地访问左子树，然后访问根节点，最后访问右子树。即遵循\"左-根-右\"原则。对于二叉搜索树，中序遍历的结果是按照升序排列的。\n后序遍历(Postorder Traversal)\n后序遍历先递归地访问左子树，然后访问右子树，最后访问根节点。即遵循\"左-右-根\"原则。这种遍历方法常用于树的删除操作。\n层序遍历(Level Order\nTraversal)\n是一种广度优先遍历方法，从根节点开始，逐层访问树中的每个节点。\n代码\n对于前三者来说，它们都是基于递归的，所以不可能做进迭代器中。在代码上它们只有访问位置的区别。\n而层序遍历是基于队列的。\nenum Order {    preorder,    inorder,    postorder,    level};void TraversalTree(Node* root, Order order) {    if (root == nullptr) return;    switch (order) {    case preorder: printf(\"%d \", root-&gt;val);  // 访问节点        TraversalTree(root-&gt;left, order);  // 递归访问左子树    case inorder: printf(\"%d \", root-&gt;val);  // 访问节点        TraversalTree(root-&gt;right, order);  // 递归访问右子树    case postorder: printf(\"%d \", root-&gt;val);  // 访问节点    case level: {        std::queue&lt;Node*&gt; que;        que.emplace(root);        while (!que.empty()) {            printf(\"%d \", root-&gt;val); // 访问节点            if (que.front()-&gt;left) que.emplace(que.front()-&gt;left); // 左节点入队            if (que.front()-&gt;right) que.emplace(que.front()-&gt;right); // 右节点入队            que.pop(); // 当前节点出队        }    }    }}\n二叉树的存储\n接下来是本文的重点。\n二叉树的存储基本可以分为两类:\n- 多重链表\n- 数组\n多重链表\n顾名思义，在一个节点中能指向多个节点的链表是多重链表。\n一个简单的节点结构可以这么写:\ntemplate &lt;class dtype&gt;struct Node {    dtype data;    Node&lt;dtype&gt;* parent;    Node&lt;dtype&gt;* left, right;}Node&lt;int&gt; root;\n它面临的问题十分明显:\n- 难以遍历\n- 无法随机读取\n- 需要额外管理内存\n作为链表，内存分配开销大本身也就是一个问题。\n由于不能随机读取，我一般使用时都会用一个哈希表来映射节点以换取速度。\n至于内存管理，简单直接的方法就是使用智能指针。当然你也可以选择用引用来构建一棵树，让别的容器来管理。\n遍历是最大的问题，如果想开放迭代器，那就只能在迭代器里实现一个BFS。那么迭代器的体积会变得多大就不用说了。\n工业上可能会用内存池之类的技术来解决上述问题，但日常使用不可能有这么大的复杂度。\n优点:\n- 直观\n- 增删移动节点容易\n数组\n在上面说了完全二叉树是可以直接存储在数组里的。但这里是将任意二叉树存储在数组中。\n首先说这么做的优点:\n- 利于遍历\n- 不需要管理内存\n基本就像这样:\nstruct Node {    int data;    size_t parent;    size_t left, right;};std::vector&lt;Node&gt; tree;\n这样看起来最大的区别就是多了一个数组。但实际上，如果你维护这个数组，使它按照树的遍历顺序排列，那么你通过直接遍历数组，就可以遍历树了。\n这里数组也可以是别的容器。但既然是为了遍历，那么也没用什么结构比数组遍历还要快。\n当然他也有缺点:\n- 增删移动慢的要命\n- 如果内存分配很保守，就会产生浪费\n这种方法适用于一次性不维护的树，因为不会有增删移动。否则还是使用多重链表。\n引用\nC/C++ 数据结构\n树】探索C/C++中的二叉树：从理论到实践\n详解二叉树的存储王道版（C++/C）\n树（数据结构名词）_百度百科\n","categories":["C++"],"tags":["Note"]}]