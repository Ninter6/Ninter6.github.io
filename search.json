[{"title":"从投影和观察矩阵提取视锥体","url":"/2024/03/02/%E4%BB%8E%E6%8A%95%E5%BD%B1%E5%92%8C%E8%A7%82%E5%AF%9F%E7%9F%A9%E9%98%B5%E6%8F%90%E5%8F%96%E8%A7%86%E9%94%A5%E4%BD%93/","content":"视锥体\n首先我不知道\"视锥体\"这个名字是否正确，但接下来我会使用这个称呼\n\n如图，视锥体是一个六面体。如果一个物体在视锥体内部，那么他就有可能显示在屏幕上。如果我们能够求出当前摄像机的视锥体，并对场景中所有物体的包围盒求交，那么我们就能过滤掉那些绝不可能显示在屏幕上的物体，从而达到减少渲染开支的目的。这其实就是可见性裁切(Visibility\nCulling)。\n想要进行上述操作，一个正确的在世界坐标下视锥体是必须的，如何求出这个视锥体，现在有两个方案:\n1. 根据相机投影矩阵参数生成，然后对原始视锥体进行变换\n2. 通过 projection-view 矩阵直接提取\n前者虽然简单，但是变换6个面还是有一点开销，所以我们选择后者，也就是本篇文章讨论的内容。\n平面方程\n先让我们回顾一下平面方程:\n\n其中平面的法向量其实就是(A, B, C)，即:\n\n而D可以视作原点到平面的距离。相信大家能看出，等式左边其实就是计算一个点到平面的距离，那我们不妨定义一个距离函数:\n\n当函数值为0时，那就意味着点P在平面上。\n\n注意: 本文接下来会直接用距离函数来表示一个平面\n\n提取视锥体\n假设有一个矩阵，时投影(projection)和观察(view)矩阵的乘积\n\n我们将一个点与之相乘\n\n接下来就会被变换到剪裁空间(Clip\nSpace)，如果对其进行透视除法(即: )，就可以将其转换到NDC(Normalized Device\nCoordinates)\n\n\n剪裁空间和NDC以vulkan中为例，下文计算也以此为准\n\n我们直接看剪裁空间的，如果可见，那么其一定满足如下条件:\n\n让我们关注的情况，先用替换，也如此\n\n只看 \n，我们不难发现这就能表示一个平面:\n\n但是我们需要平面的法向量是单位向量的，所以还需要归一化:\n\n我们用归一化后的来表示这个平面:\n\n\n注意：这里是两个四维向量相乘，平面方程的四个系数其实就是的四个分量\n\n这时只有点P在平面上方时，P才可能可见。\n对于  ，我们也如法炮制:\n\n同样也用一个平面来表示:\n\n依然只有点P在平面上方时，P才可能可见。\n我们不难举一反三写出所有六个面的方程:\n\n\n注意vulkan中NDC顶部是-1\n\n实现代码\n最后附上可能的c++实现代码。\nstd::array&lt;vec4, 6&gt; CreateViewingFrustumFromMatrix(const mat4&amp; mat, float x_left, float x_right, float y_top, float y_bottom, float z_near, float z_far) {    std::array&lt;vec4, 6&gt; f;    auto&amp; plane_right   = f[0];    auto&amp; plane_left    = f[1];    auto&amp; plane_top     = f[2];    auto&amp; plane_bottom  = f[3];    auto&amp; plane_near    = f[4];    auto&amp; plane_far     = f[5];#define NORMALIZE(x) do { \\    float rlen = 1.f / std::sqrtf(vec3(x).length_squared()); \\    x *= rlen; \\} while(0)    auto mat_column = mat.transposed();        plane_right = mat_column[3] * x_right - mat_column[0];    NORMALIZE(plane_right);    plane_left = mat_column[0] - mat_column[3] * x_left;    NORMALIZE(plane_left);    plane_top = mat_column[3] * y_top - mat_column[1];    NORMALIZE(plane_top);    plane_bottom = mat_column[1] - mat_column[3] * y_bottom;    NORMALIZE(plane_bottom);    plane_near = mat_column[2] - mat_column[3] * z_near;    NORMALIZE(plane_near);    plane_far = mat_column[3] * z_far - mat_column[2];    NORMALIZE(plane_far);    return f;    #undef NORMALIZE}\n引用\nFast\nExtraction of Viewing Frustum Planes from the WorldView -\nProjectionMatrix\n","categories":["Computer Graphics"],"tags":["Note"]},{"title":"Viewing world at 60Hz","url":"/2024/02/24/Viewing-world-at-60Hz/","content":"Introduction\n首先简单说一下这个博客的名字，Viewing world at\n60Hz(60Hz看世界)\n为啥叫这个名呢\n你想，宇宙运转的那么快，上帝拥有几乎无限的算力，世界反应一帧可以说不用时间\n而人类呢，反应迟钝，一秒顶多思考60次\n但尽管如此，宇宙那神秘的面纱在人类面前仍然触手可及\n那么，这篇博客的用意也很明显\n用这个时代给予的特权，用仅仅60Hz思维频率\n观察宇宙，了解宇宙，感受宇宙\n\n宇宙最不可理解之处，就在于它是可理解的 --Albert Einstein\n\nWhat can I say\n不管怎么说，这总归是一个学术博客，我会在这发布一些学术文章\n可能包含:\n- C++\n- Computer Graphics\n- ... // I haven't decided yet.\n可能会开放一个图书角，放一些相关书籍\n\n个人发电，不定时更新\n\n不善言辞，就不多说了，也不想就第一篇文章，还要改好几次\nTo Be Continued\n最后放一张图片，是别人为我做的，随便放的没有什么别的意思\n","categories":["Useless"],"tags":["null"]}]