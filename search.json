[{"title":"从投影和观察矩阵提取视锥体","url":"/2024/03/02/%E4%BB%8E%E6%8A%95%E5%BD%B1%E5%92%8C%E8%A7%82%E5%AF%9F%E7%9F%A9%E9%98%B5%E6%8F%90%E5%8F%96%E8%A7%86%E9%94%A5%E4%BD%93/","content":"视锥体\n首先我不知道\"视锥体\"这个名字是否正确，但接下来我会使用这个称呼\n\n如图，视锥体是一个六面体。如果一个物体在视锥体内部，那么他就有可能显示在屏幕上。如果我们能够求出当前摄像机的视锥体，并对场景中所有物体的包围盒求交，那么我们就能过滤掉那些绝不可能显示在屏幕上的物体，从而达到减少渲染开支的目的。这其实就是可见性裁切(Visibility\nCulling)。\n想要进行上述操作，一个正确的在世界坐标下视锥体是必须的，如何求出这个视锥体，现在有两个方案:\n1. 根据相机投影矩阵参数生成，然后对原始视锥体进行变换\n2. 通过 projection-view 矩阵直接提取\n前者虽然简单，但是变换6个面还是有一点开销，所以我们选择后者，也就是本篇文章讨论的内容。\n平面方程\n先让我们回顾一下平面方程:\n\n其中平面的法向量其实就是(A, B, C)，即:\n\n而D可以视作原点到平面的距离。相信大家能看出，等式左边其实就是计算一个点到平面的距离，那我们不妨定义一个距离函数:\n\n当函数值为0时，那就意味着点P在平面上。\n\n注意: 本文接下来会直接用距离函数来表示一个平面\n\n提取视锥体\n假设有一个矩阵，时投影(projection)和观察(view)矩阵的乘积\n\n我们将一个点与之相乘\n\n接下来就会被变换到剪裁空间(Clip\nSpace)，如果对其进行透视除法(即: )，就可以将其转换到NDC(Normalized Device\nCoordinates)\n\n\n剪裁空间和NDC以vulkan中为例，下文计算也以此为准\n\n我们直接看剪裁空间的，如果可见，那么其一定满足如下条件:\n\n让我们关注的情况，先用替换，也如此\n\n只看 \n，我们不难发现这就能表示一个平面:\n\n但是我们需要平面的法向量是单位向量的，所以还需要归一化:\n\n我们用归一化后的来表示这个平面:\n\n\n注意：这里是两个四维向量相乘，平面方程的四个系数其实就是的四个分量\n\n这时只有点P在平面上方时，P才可能可见。\n对于  ，我们也如法炮制:\n\n同样也用一个平面来表示:\n\n依然只有点P在平面上方时，P才可能可见。\n我们不难举一反三写出所有六个面的方程:\n\n\n注意vulkan中NDC顶部是-1\n\n实现代码\n最后附上可能的c++实现代码。\nstd::array&lt;vec4, 6&gt; CreateViewingFrustumFromMatrix(const mat4&amp; mat, float x_left, float x_right, float y_top, float y_bottom, float z_near, float z_far) {    std::array&lt;vec4, 6&gt; f;    auto&amp; plane_right   = f[0];    auto&amp; plane_left    = f[1];    auto&amp; plane_top     = f[2];    auto&amp; plane_bottom  = f[3];    auto&amp; plane_near    = f[4];    auto&amp; plane_far     = f[5];#define NORMALIZE(x) do { \\    float rlen = 1.f / std::sqrtf(vec3(x).length_squared()); \\    x *= rlen; \\} while(0)    auto mat_column = mat.transposed();        plane_right = mat_column[3] * x_right - mat_column[0];    NORMALIZE(plane_right);    plane_left = mat_column[0] - mat_column[3] * x_left;    NORMALIZE(plane_left);    plane_top = mat_column[3] * y_top - mat_column[1];    NORMALIZE(plane_top);    plane_bottom = mat_column[1] - mat_column[3] * y_bottom;    NORMALIZE(plane_bottom);    plane_near = mat_column[2] - mat_column[3] * z_near;    NORMALIZE(plane_near);    plane_far = mat_column[3] * z_far - mat_column[2];    NORMALIZE(plane_far);    return f;    #undef NORMALIZE}\n引用\nFast\nExtraction of Viewing Frustum Planes from the WorldView -\nProjectionMatrix\n","categories":["Graphics"],"tags":["Note"]},{"title":"Viewing world at 60Hz","url":"/2024/02/24/Viewing-world-at-60Hz/","content":"Introduction\n首先简单说一下这个博客的名字，Viewing world at\n60Hz(60Hz看世界)\n为啥叫这个名呢\n你想，宇宙运转的那么快，上帝拥有几乎无限的算力，世界反应一帧可以说不用时间\n而人类呢，反应迟钝，一秒顶多思考60次\n但尽管如此，宇宙那神秘的面纱在人类面前仍然触手可及\n那么，这篇博客的用意也很明显\n用这个时代给予的特权，用仅仅60Hz思维频率\n观察宇宙，了解宇宙，感受宇宙\n\n宇宙最不可理解之处，就在于它是可理解的 --Albert Einstein\n\nWhat can I say\n不管怎么说，这总归是一个学术博客，我会在这发布一些学术文章\n可能包含:\n- C++\n- Computer Graphics\n- ... // I haven't decided yet.\n可能会开放一个图书角，放一些相关书籍\n\n个人发电，不定时更新\n\n不善言辞，就不多说了，也不想就第一篇文章，还要改好几次\nTo Be Continued\n最后放一张图片，是别人为我做的，随便放的没有什么别的意思\n","categories":["Useless"],"tags":["null"]},{"title":"二叉树浅谈","url":"/2024/03/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B5%85%E8%B0%88/","content":"前言\n这几天突发奇想研究了一下二叉树，发现这东西确实有些能讲的。这篇算是一个笔记，也算记录一下自己的一些疑惑。\n树绝对是一种非常常用的数据结构，但c++stl并没有提供现成的容器，每次都需要自己实现。所以这篇文章也会记录一下，我在实践中遇到的问题。\n树\n树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n它具有以下的特点:\n- 每个节点有零个或多个子节点；\n- 没有父节点的节点称为根节点；\n- 每一个非根节点有且只有一个父节点；\n-\n除了根节点外，每个子节点可以分为多个不相交的子树(Subtree)\n补充性质:\n- 根节点到达每个节点的路径是唯一的\n\n树的概念不再过多赘述，更多信息请看引用，这里再强调一些重点:\n- 度: 子节点的个数\n- 深度: 根到此节点的经过的连接数\n- 树的高度: 最大深度+1\n- 根节点: 没有父亲的节点\n- 中间节点: 有父亲有孩子的节点\n- 叶子节点: 没有孩子的节点\n二叉树\n二叉树(Binary Tree)最直接的定义: 度为2的树\n二叉树作为一种特殊的树，拥有树的所有性质。\n特殊的二叉树\n空二叉树(Empty Binary Tree)\n没有节点的二叉树。空二叉树的高度是0。\n满二叉树(Full Binary Tree)\n除了叶子节点都有两个孩子。任一节点的子树都是满二叉树。\n只有根节点或着空二叉树也是满二叉树。\n性质:\n- 如果层序遍历这棵树，那么n号节点的两个孩子必然是(2n+1)和(2n+2)\n- 高度为k的满二叉树共有(2^k-1)个节点\n完全二叉树(Completed Binary\nTree)\n一棵深度为k的有n个结点的二叉树，按层序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。\n完全二叉树由于其特殊的性质，所以可以直接存储在数组中。stl中的std::make_heap也是这个原理。\n平衡二叉树(Balanced Binary\nTree)\n任一节点子树的深度差不超过1。\n平衡二叉树可以提高搜索效率。\n完全二叉树是平衡二叉树。\n二叉搜索树(Binary Search\nTree)\n二叉搜索树中每个节点都满足以下性质:\n- 所有左子树的节点的值都小于该节点的值；\n- 所有右子树的节点的值都大于该节点的值。\n二叉树的遍历\n前序遍历(Preorder Traversal)\n是一种深度优先遍历方法，会从根节点开始，然后遍历左子树，其次右子树。即遵循\"根-左-右\"原则。\n中序遍历(Inorder Traversal)\n首先递归地访问左子树，然后访问根节点，最后访问右子树。即遵循\"左-根-右\"原则。对于二叉搜索树，中序遍历的结果是按照升序排列的。\n后序遍历(Postorder Traversal)\n后序遍历先递归地访问左子树，然后访问右子树，最后访问根节点。即遵循\"左-右-根\"原则。这种遍历方法常用于树的删除操作。\n层序遍历(Level Order\nTraversal)\n是一种广度优先遍历方法，从根节点开始，逐层访问树中的每个节点。\n代码\n对于前三者来说，它们都是基于递归的，所以不可能做进迭代器中。在代码上它们只有访问位置的区别。\n而层序遍历是基于队列的。\nenum Order {    preorder,    inorder,    postorder,    level};void TraversalTree(Node* root, Order order) {    if (root == nullptr) return;    switch (order) {    case preorder: printf(\"%d \", root-&gt;val);  // 访问节点        TraversalTree(root-&gt;left, order);  // 递归访问左子树    case inorder: printf(\"%d \", root-&gt;val);  // 访问节点        TraversalTree(root-&gt;right, order);  // 递归访问右子树    case postorder: printf(\"%d \", root-&gt;val);  // 访问节点    case level: {        std::queue&lt;Node*&gt; que;        que.emplace(root);        while (!que.empty()) {            printf(\"%d \", root-&gt;val); // 访问节点            if (que.front()-&gt;left) que.emplace(que.front()-&gt;left); // 左节点入队            if (que.front()-&gt;right) que.emplace(que.front()-&gt;right); // 右节点入队            que.pop(); // 当前节点出队        }    }    }}\n二叉树的存储\n接下来是本文的重点。\n二叉树的存储基本可以分为两类:\n- 多重链表\n- 数组\n多重链表\n顾名思义，在一个节点中能指向多个节点的链表是多重链表。\n一个简单的节点结构可以这么写:\ntemplate &lt;class dtype&gt;struct Node {    dtype data;    Node&lt;dtype&gt;* parent;    Node&lt;dtype&gt;* left, right;}Node&lt;int&gt; root;\n它面临的问题十分明显:\n- 难以遍历\n- 无法随机读取\n- 需要额外管理内存\n作为链表，内存分配开销大本身也就是一个问题。\n由于不能随机读取，我一般使用时都会用一个哈希表来映射节点以换取速度。\n至于内存管理，简单直接的方法就是使用智能指针。当然你也可以选择用引用来构建一棵树，让别的容器来管理。\n遍历是最大的问题，如果想开放迭代器，那就只能在迭代器里实现一个BFS。那么迭代器的体积会变得多大就不用说了。\n工业上可能会用内存池之类的技术来解决上述问题，但日常使用不可能有这么大的复杂度。\n优点:\n- 直观\n- 增删移动节点容易\n数组\n在上面说了完全二叉树是可以直接存储在数组里的。但这里是将任意二叉树存储在数组中。\n首先说这么做的优点:\n- 利于遍历\n- 不需要管理内存\n基本就像这样:\nstruct Node {    int data;    size_t parent;    size_t left, right;};std::vector&lt;Node&gt; tree;\n这样看起来最大的区别就是多了一个数组。但实际上，如果你维护这个数组，使它按照树的遍历顺序排列，那么你通过直接遍历数组，就可以遍历树了。\n这里数组也可以是别的容器。但既然是为了遍历，那么也没用什么结构比数组遍历还要快。\n当然他也有缺点:\n- 增删移动慢的要命\n- 如果内存分配很保守，就会产生浪费\n这种方法适用于一次性不维护的树，因为不会有增删移动。否则还是使用多重链表。\n引用\nC/C++ 数据结构\n树】探索C/C++中的二叉树：从理论到实践\n详解二叉树的存储王道版（C++/C）\n树（数据结构名词）_百度百科\n","categories":["C++"],"tags":["Note"]},{"title":"编写一个JSON解析器「C++」","url":"/2024/06/21/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAJson%E8%A7%A3%E6%9E%90%E5%99%A8/","content":"目录\n\n\n简介\n\n\n什么是JSON\n\n\n1.1 JSON的基本数据类型\n1.2 JSON中的token\n\n\n封装一个JSON容器\n\n\n2.1 数据存储\n2.2 包装\n\n\n实现JSON解析器\n\n\n3.1 JsonScanner\n3.2 JsonParser\n\n\n简介\n\n本站主打“一文通”\n\n之前打磨了一下自己的工具库，这个JSON解析器算少数几个还能用的，索性重写了一下。现在自我感觉良好，所以分享一下。\n什么是JSON\nJSON作为一种轻量级资料交换格式，具有易于阅读和处理的优势。\nJSON的基本数据类型\n\n数值: 不区分整数与浮点数，用双精度浮点数表示所有数值。\n字符串:\n以双引号\"\"括起来的零个或多个Unicode码位。支持反斜杠开始的转义字符序列。\n布尔值：表示为true或者false。\n数组：有序的零个或者多个值。每个值可以为任意类型。数组使用方括号[]包裹。多个数组元素之间用逗号,分隔，形如：[value, value]。\n对象：若干无序的“键-值对”(key-value\npairs)，其中键只能是字符串。建议但不强制要求对象中的键是独一无二的。对象以花括号{}包裹。多个键-值对之间使用逗号,分隔。键与值之间用冒号:分隔。\n空值：值写为null。\n\nJSON中的token\n\n6种标点符号: {} [] ,\n:\n3种字面量: false true\nnull\n字符串\n数值\n\n除此之外，四个特定字符被认为是空白符：空格符、水平制表符、回车符、换行符。JSON标准不允许有字节序掩码，不提供注释的句法。\n封装一个JSON容器\n了解了JSON的基本语法后就可以着手实现解析器了。让我们先从JSON容器开始。\n数据存储\n首先明确我们存储JSON数据的底层类型。\nclass Json;using JsonObject = std::unordered_map&lt;std::string, Json&gt;;using JsonArray = std::vector&lt;Json&gt;;using JsonString = std::string;using JsonNumber = double;using JsonBoolean = bool;\n因为一个JSON元素可能为这6个基本数据类型和空值中的任意一个，所以我们需要一个多态类型存储。可以用std::variant来实现这个多态，但我选择虚拟类。\nstruct JsonElementBase {    virtual ~JsonElementBase() = default;    [[nodiscard]] virtual JsonElementBase* clone() const = 0;    // ...    // 读取和判断值的一些方法    [[nodiscard]] virtual std::string dumps() const = 0; // 将数据转化为JSON文本    [[nodiscard]] virtual JsonType type() const = 0; // 获取类型};\n为了判断一个JSON元素中到底存储的是什么类型的值，我们需要一个包含6个基本数据类型的枚举。\n这里我引入了X-MACRO来简化代码，这个在后面作用比较大。\n#define JSON_TYPE_NON_NULL(f) \\    f(Object) \\    f(Array) \\    f(String) \\    f(Number) \\    f(Boolean)#define JSON_TYPE(f) \\    JSON_TYPE_NON_NULL(f) \\    f(Null)enum class JsonType {#define g(x) x,    JSON_TYPE(g)#undef g};\n接下来可以写完JSON元素的剩余几个接口。\n#define g(x) virtual Json##x&amp; as##x() = 0;    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual const Json##x&amp; as##x() const = 0;    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual bool is##x() const = 0;    JSON_TYPE(g);#undef g\n其中包括:\n- asXXX()(两个版本): 读取实际存储的值。\n- isXXX(): 判断存储的值是否为某类型。\n接下来为各各数据类型创建类，以及一种默认情况。\n#define ERROR(s) do{throw std::logic_error(s);}while(0)struct JsonElement : public JsonElementBase {#define g(x) virtual Json##x&amp; as##x() {ERROR(\"Call 'asXXX()' with wrong type!\");}    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual const Json##x&amp; as##x() const {ERROR(\"Call 'asXXX()' with wrong type!\");}    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual bool is##x() const {return false;}    JSON_TYPE(g);#undef g};\n默认情况下asXXX()会抛异常，isXXX()返回false。接下来只要覆盖特定功能函数就行了。\n后面的代码比较重复，优先写宏。\n#define BEGIN_ELEMENT(n) \\    struct JsonElement##n : public JsonElement { \\        Json##n val; \\        JsonElement##n() = default; \\        JsonElement##n(const Json##n&amp; val) : val(val) {} \\        JsonElement##n(Json##n&amp;&amp; val) : val(std::move(val)) {} \\        JsonElementBase* clone() const override {return new JsonElement##n(val);} \\        Json##n&amp; as##n() override {return val;} \\        const Json##n&amp; as##n() const override {return val;} \\        bool is##n() const override {return true;} \\        JsonType type() const override {return JsonType:: n;}#define END_ELEMENT() };\n每个类型实现如下:\nBEGIN_ELEMENT(Object)    std::string dumps() const override {        std::stringstream ss;        ss &lt;&lt; val;        return ss.str();    }END_ELEMENT() // ObjectBEGIN_ELEMENT(Array)    virtual std::string dumps() const override {        std::stringstream ss;        ss &lt;&lt; val;        return ss.str();    }END_ELEMENT() // ArrayBEGIN_ELEMENT(String)    std::string dumps() const override {        std::stringstream ss;        ss &lt;&lt; std::quoted(val);        return ss.str();    }END_ELEMENT() // StringBEGIN_ELEMENT(Number)    std::string dumps() const override {        auto s = std::to_string(val);        if (s.find('.') &lt; s.size()) {            auto n = s.find_last_not_of('0');            s.erase(s[n-1] == '.' ? n-1 : n);        }        return s;    }END_ELEMENT() // NumberBEGIN_ELEMENT(Boolean)    std::string dumps() const override {        return val ? \"true\" : \"false\";    }END_ELEMENT() // Booleanstruct JsonElementNull : public JsonElement {    JsonElementNull() = default;    JsonElementBase* clone() const override {return new JsonElementNull();}    bool isNull() const override {return true;}    JsonType type() const override {return JsonType::Null;}    std::string dumps() const override {return \"null\";}}; // Null\n除了JSON文本转换没什么特别要写的。不过null比较特殊，因为他没有数据成员。\n包装\n弄完这些就可以包装为最终的JSON容器了。\n看起来像是这样:\nclass Json {public:    Json() : element(std::make_unique&lt;JsonElementNull&gt;()) {}    Json(const Json&amp; o) : element(o.element-&gt;clone());    Json(Json&amp;&amp; o) noexcept : element(std::move(o.element));    Json&amp; operator=(const Json&amp; o) {        element.reset(o.element-&gt;clone());    }    Json&amp; operator=(Json&amp;&amp; o) noexcept {        element = std:move(o.element);    }#define g(x) Json(const Json##x&amp; v);    JSON_TYPE_NON_NULL(g)#undef g#define g(x) Json(Json##x&amp;&amp; v);    JSON_TYPE_NON_NULL(g)#undef g#define g(x) Json##x&amp; as##x();    JSON_TYPE_NON_NULL(g)#undef g#define g(x) const Json##x&amp; as##x() const;    JSON_TYPE_NON_NULL(g)#undef g#define g(x) bool is##x() const;    JSON_TYPE(g);#undef g#define g(x) static Json Make##x() {return Json(Json##x{});}    JSON_TYPE_NON_NULL(g)    static Json MakeNull() {return Json{};}#undef g    std::string dumps() const;    JsonType type() const;    Json&amp; operator[](const std::string&amp; k) {        assert(isObject() &amp;&amp; \"Element isn't an object!\");        return asObject()[k];    }    const Json&amp; operator[](const std::string&amp; k) const {        assert(isObject() &amp;&amp; \"Element isn't an object!\");        return asObject().at(k);    }    Json&amp; operator[](size_t n) {        assert(isArray() &amp;&amp; \"Element isn't an array!\");        return asArray()[n];    }    const Json&amp; operator[](size_t n) const {        assert(isArray() &amp;&amp; \"Element isn't an array!\");        return asArray()[n];    }    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Json&amp; json) {        return os &lt;&lt; json-&gt;dumps();    }    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const JsonObject&amp; object) {        os &lt;&lt; \"{\";        for (auto iter = object.begin(); iter != object.end(); iter++) {            os &lt;&lt; '\\\"' &lt;&lt; iter-&gt;first &lt;&lt; '\\\"' &lt;&lt; \": \" &lt;&lt; iter-&gt;second;            if (std::next(iter) != object.end()) {                os &lt;&lt; \", \";            }        }        os &lt;&lt; \"}\";        return os;    }    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const JsonArray&amp; array) {        os &lt;&lt; \"[\";        for (size_t i = 0; i &lt; array.size(); i++) {            os &lt;&lt; array[i];            if (i != array.size() - 1) {                os &lt;&lt; \", \";            }        }        os &lt;&lt; \"]\";        return os;    }private:    std::unique_ptr&lt;JsonElementBase&gt; element;};\n上面的代码省略了部分工具函数的实现。\n实现JSON解析器\n然后是JSON的解析。\nJsonScanner\n我们首先需要一个工具类来识别JSON的token。\n它应该包含如下功能:\n- Scan(): 返回一个token\n- Rollback(): 回到上一个token\n- GetStringValue(): 返回读到的字符串token的值\n- GetNumberValue(): 返回读到的数字token的值\n我们需要一个枚举来区分token:\nenum class JsonTokenType {    BEGIN_OBJECT, // {    END_OBJECT, // }    BEGIN_ARRAY, // [    END_ARRAY, // ]    VALUE_SEPARATOR, // ,    NAME_SEPARATOR, // :    VALUE_STRING, // \"string\"    VALUE_NUMBER, // 1, 2, ...    LITERAL_TRUE, // true    LITERAL_FALSE, // false    LITERAL_NULL, // null    END_OF_SOURCE // EOF};\n那么我们就可以开始编写这个类。\nclass JsonScanner {public:    JsonScanner() = default;    JsonScanner(const std::string&amp; source) : src(source) {}    JsonTokenType Scan() {        if (IsAtEnd()) {            return JsonTokenType::END_OF_SOURCE;        }        prev_pos = current;        char c = Advance();        switch (c) {            case '{':                return JsonTokenType::BEGIN_OBJECT;            case '}':                return JsonTokenType::END_OBJECT;            case '[':                return JsonTokenType::BEGIN_ARRAY;            case ']':                return JsonTokenType::END_ARRAY;            case ':':                return JsonTokenType::NAME_SEPARATOR;            case ',':                return JsonTokenType::VALUE_SEPARATOR;            case 't':                ScanTrue();                return JsonTokenType::LITERAL_TRUE;            case 'f':                ScanFlase();                return JsonTokenType::LITERAL_FALSE;            case 'n':                ScanNull();                return JsonTokenType::LITERAL_NULL;            case '\"':                ScanString();                return JsonTokenType::VALUE_STRING;            default:                if (std::isdigit(c) || c == '+' || c == '-') {                    ScanNumber();                    return JsonTokenType::VALUE_NUMBER;                }                if (std::isspace(c)) {                    return Scan();                }                ERROR(std::string(\"Unsupported Token: \") + c);                break;        }    }    void Rollback() {        current = prev_pos;    }    JsonString GetStringValue() {        return value_string;    }    JsonNumber GetNumberValue() {        return value_number;    }private:    std::string src; // json source    size_t current = 0; // current handling pos    size_t prev_pos = 0; // previous handling pos    JsonString value_string;    JsonNumber value_number;    // ...    // 其他成员函数};\n基本逻辑就是看到什么就读什么，我们只需要识别和跳过字符。\n成员函数:\nbool IsAtEnd() {    return current &gt;= src.size();}char Advance() {    if (current &lt; src.size()) return src[current++];    else return 0;}char Peek() {    if (current &lt; src.size()) return src[current];    else return 0;}char PeekNext() {    if (current &lt; src.size()) return src[current + 1];    else return 0;}void ScanTrue() {    if (src.compare(current, 3, \"rue\") == 0) {        current += 3;    } else {        ERROR(\"Scan 'true' error\");    }}void ScanFlase() {    if (src.compare(current, 4, \"alse\") == 0) {        current += 4;    } else {        ERROR(\"Scan 'false' error\");    }}void ScanNull() {    if (src.compare(current, 3, \"ull\") == 0) {        current += 3;    } else {        ERROR(\"Scan 'null' error\");    }}void ScanNumber() {    auto pos = current - 1;    bool dotflag = true, eflag = true;    while (std::isdigit(Peek()) ||            (Peek() == '.' &amp;&amp; dotflag) ||            ((Peek() == 'e' || Peek() == 'E') &amp;&amp; eflag)) {        if (Peek() == '.') {            dotflag = false;        } else if (Peek() == 'e' || Peek() == 'E') {            eflag = false;            Advance(); // '+' and '-' may follow 'e'        }        Advance();    }    value_number = std::stof(src.substr(pos, current - pos));}void ScanString() {    std::string r;    char c;    while((c = Advance()) != '\"' &amp;&amp; !IsAtEnd()) {        if (c == '\\\\') {            switch (c = Advance()) {                case '\\\\': r += '\\\\'; break;                case 'n': r += '\\n'; break;                case 't': r += '\\t'; break;                case 'r': r += '\\r'; break;                case 'b': r += '\\b';  break;                case 'f': r += '\\f'; break;                case 'a': r += '\\a'; break;                case 'v': r += '\\v'; break;                default: r += c; break;            }        } else {            r += c;        }    }    if (IsAtEnd()) {        ERROR(\"Invalid string: missing closing quote!\");    }    value_string = r;}\n字符串会麻烦一点，因为要处理转意符。\nJsonParser\n最后是这个用于解析的类。通过一个Parse()函数返回解析的Json实例。\nclass JsonParser {public:    JsonParser() = default;    JsonParser(const std::string&amp; str) : scanner(str) {}    JsonParser(const JsonScanner&amp; scanner) : scanner(scanner) {}    Json Parse() {        auto token_type = scanner.Scan();        switch (token_type) {            case JsonTokenType::BEGIN_OBJECT:                return {ParseObject()};            case JsonTokenType::BEGIN_ARRAY:                return {ParseArray()};            case JsonTokenType::VALUE_STRING: {                const auto&amp; str = scanner.GetStringValue();                return {str};            }            case JsonTokenType::VALUE_NUMBER: {                auto num = scanner.GetNumberValue();                return {num};            }            case JsonTokenType::LITERAL_TRUE:                return {true};            case JsonTokenType::LITERAL_FALSE:                return {false};            case JsonTokenType::LITERAL_NULL:            case JsonTokenType::END_OF_SOURCE:            default:                return {};        }    }private:    JsonScanner scanner;    JsonObject ParseObject();    JsonArray ParseArray();};\n同样的逻辑，根据token判断值，只是如果是JSON对象和数组的话就需要递归读取。\n对象需要分别读键和值。\nJsonObject ParseObject() {    JsonObject rst{};    auto next = scanner.Scan();    if (next == JsonScanner::JsonTokenType::END_OBJECT) {        return rst;    }    scanner.Rollback();    while (true) {        next = scanner.Scan();        if (next != JsonScanner::JsonTokenType::VALUE_STRING) {            ERROR(\"Key must be string!\");        }        std::string key = scanner.GetStringValue();        next = scanner.Scan();        if (next != JsonScanner::JsonTokenType::NAME_SEPARATOR) {            ERROR(\"Expected ':'!\");        }        rst.insert({key, Parse()});        next = scanner.Scan();        if (next == JsonScanner::JsonTokenType::END_OBJECT) {            break;        }        if (next != JsonScanner::JsonTokenType::VALUE_SEPARATOR) {            ERROR(\"Expected ','!\");        }    }    return rst;}\n数组一个一个读取就行。\nJsonArray ParseArray() {    JsonArray rst;    auto next = scanner.Scan();    if (next == JsonScanner::JsonTokenType::END_ARRAY) {        return rst;    }    scanner.Rollback();    while (true) {        rst.push_back(Parse());        next = scanner.Scan();        if (next == JsonScanner::JsonTokenType::END_ARRAY) {            break;        }        if (next != JsonScanner::JsonTokenType::VALUE_SEPARATOR) {            ERROR(\"Expected ','!\");        }    }    return rst;}\n别让别人吃你拉的屎。\n#undef BEGIN_ELEMENT#undef END_ELEMENT#undef ERROR#undef JSON_TYPE#undef JSON_TYPE_NON_NULL\n","categories":["C++"],"tags":["Experiment"]},{"title":"weighted blended","url":"/2024/08/11/weighted-blended/","content":"\n\n前言(废话)\n\n赶快水一篇，不然暑假就结束了\n\nWeighted Blended\n介绍\nWeighted\nBlended是一种较为简单的，快速高效的顺序无关混合算法，它大多数情况下比排序图元或者片元快得多，\n相对空间的占用也较小。\nWeighted\nBlended通过计算一个权重，其只与颜色的alpha和片元的深度有关，以此做到与混合的顺序无关。\n使用这种技术需要对渲染管线的修改是非常小的。非透明部分的渲染会原封不动地保留，只需要对透明物体渲染做特殊处理，最后叠加到非透明部分上。这对旧代码非常友善。\n\n更多介绍请看Learn OpenGL：Weighted\nBlended\n\n本文将探讨其的实现，无关内容不作过多赘述\n预览\n实现此算法的步骤如下:\n\n创建帧缓冲，以及至少两个颜色附件(revealage, accumulation)\n渲染不透明物体\n配置透明pass\n渲染透明物体\n叠加帧缓冲内容到不透明帧缓冲上\n\n\n如果要使用深度测试，将深度附件也绑定到帧缓冲上，这样的话你可能需要为不透明物体也创建一个帧缓冲(或着一个帧缓冲带有两个pass)\n\n因为要透明pass要输出到两个附件上，所以需要OpenGL4.0以上的版本。在不支持此版本的设备上，渲染两次可能是最简单的方法。\n先让我们编写一个简单的程序，没有实现OIT:\n#include &lt;iostream&gt;#include &lt;cassert&gt;#include \"glad/glad.h\"#include \"GLFW/glfw3.h\"constexpr int W = 800, H = 500;constexpr float vert[] = { -.5,-.5, .5,.5, .5,-.5, -.5,.5, .5,.5, -.5,-.5 };float proj[4*4]{}, _init_matrix = ([]{ // NOLINT(*-reserved-identifier)    float aspect = (float)W / (float)H;    float tanHalfFov = std::tan(.5f); // tan(pi/3/2)    float near = 0.1f, far = 100.0f;    proj[0] = 1.0f / (aspect * tanHalfFov);    proj[5] = 1.0f / tanHalfFov;    proj[10] = (far + near) / (near - far);    proj[11] =-1.0f;    proj[14] = (2.0f * far * near) / (near - far);}(), 0.f);constexpr auto circle_vsh = R\"(#version 410 corelayout (location = 0) in vec2 pos;out vec2 fragUV;out vec4 fragCol;uniform float t;uniform mat4 proj;const vec4 colors[] = vec4[](    vec4(.06f, .93f, .8f, .5f),    vec4(1.f, .68f, .2f, .5f),    vec4(.37f, .83f, .09f, .5f),    vec4(.87f, .93f, .2f, .5f),    vec4(1.f, .67, .47f, .5f),    vec4(1.f, .37f, .4f, .5f));void main() {    fragUV = pos * 2;    fragCol = colors[gl_InstanceID];    vec4 p = vec4(pos.x - sin(t + gl_InstanceID), pos.y, -3 - cos(t + gl_InstanceID), 1);    gl_Position = proj * p;})\", circle_fsh = R\"(#version 410 corein vec2 fragUV;in vec4 fragCol;out vec4 color;void main() {    if (length(fragUV) &gt; 0.8) discard;    color = fragCol;})\";constexpr auto homo_vsh = R\"(#version 410 corelayout (location = 0) in vec2 pos;vec2 scale[] = vec2[](    vec2(2./25., 1),    vec2(2./25., 1),    vec2(2./25., 3./5.), vec2(2./25., 1./5.), vec2(2./25., 1),    vec2(6./25., 1./5.), vec2(2./25., 1./5.), vec2(6./25., 1./5.), vec2(2./25., 1./5.), vec2(6./25., 1./5.),    vec2(2./25., 1),    vec2(2./25., 3./5.), vec2(2./25., 1./5.), vec2(2./25., 1));vec2 offset[] = vec2[](    vec2(-16./25., 0),    vec2(-12./25., 0),    vec2(-8./25., 1./5.), vec2(-6./25., 0), vec2(-4./25., 0),    vec2(2./25., 2./5.), vec2(0, 1./5.), vec2(2./25., 0), vec2(4./25., -1./5.), vec2(2./25., -2./5.),    vec2(8./25., 0),    vec2(12./25., 1./5.), vec2(14./25., 0), vec2(16./25., 0));void main() {    gl_Position = vec4(pos * scale[gl_InstanceID] + offset[gl_InstanceID], 0, 1);})\", homo_fsh = R\"(#version 410 coreout vec4 color;void main() { color = vec4(1, 0.333, 0, 1); })\";GLFWwindow* window;GLuint createShader(const char* vsh, const char* fsh);int main() {    if (glfwInit() == GLFW_FALSE)        assert(false &amp;&amp; \"failed to initialize GLFW\");    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    window = glfwCreateWindow(W/2, H/2, \"weighted blended\", nullptr, nullptr);#else    window = glfwCreateWindow(W, H, \"weighted blended\", nullptr, nullptr);#endif    assert(window &amp;&amp; \"failed to create window\");    glfwMakeContextCurrent(window);    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))        assert(false &amp;&amp; \"failed to initialize GLAD\");    glEnable(GL_BLEND);    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);    glViewport(0, 0, W, H);    GLuint circle = createShader(circle_vsh, circle_fsh), homo = createShader(homo_vsh, homo_fsh);    glUseProgram(circle);    glUniformMatrix4fv(glGetUniformLocation(circle, \"proj\"), 1, GL_FALSE, proj);    GLuint vao, vbo;    glGenVertexArrays(1, &amp;vao);    glBindVertexArray(vao);    glGenBuffers(1, &amp;vbo);    glBindBuffer(GL_ARRAY_BUFFER, vbo);    glBufferData(GL_ARRAY_BUFFER, sizeof(vert), vert, GL_STATIC_DRAW);    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), nullptr);    glEnableVertexAttribArray(0);    while (!glfwWindowShouldClose(window)) {        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        glUseProgram(homo);        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 14);        glUseProgram(circle);        glUniform1f(glGetUniformLocation(circle, \"t\"), (float)glfwGetTime() * .5f);        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 6);        glfwSwapBuffers(window);        glfwPollEvents();    }    return 0;}GLuint createShader(const char* vsh, const char* fsh) {    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vsh, nullptr);    glCompileShader(vertexShader);    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fsh, nullptr);    glCompileShader(fragmentShader);    GLuint program = glCreateProgram();    glAttachShader(program, vertexShader);    glAttachShader(program, fragmentShader);    glLinkProgram(program);    GLint success;    glGetProgramiv(program, GL_LINK_STATUS, &amp;success);    if(!success) {        GLint length;        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;length);        std::string infoLog(\"\\0\", length);        glGetProgramInfoLog(program, 512, nullptr, infoLog.data());        throw std::runtime_error(\"Failed to link shader:\\n\" + infoLog);    }    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader);    return program;}\n如果正常编译你将看到以下图像，当然效果不尽人意。\n创建帧缓冲\nGLuint fbo;glGenFramebuffers(1, &amp;fbo);glBindFramebuffer(GL_FRAMEBUFFER, fbo);\n然后是必要的accum和reveal附件。下面这个表格清晰明了地展示了两份附件和其内容的关系:\n\n\n\n附件\n格式\nclear\nblend func\n内容\n\n\n\n\naccum\nRGBA16F\n(0,0,0,0)\nONE, ONE\n(rgb * a, a) * w\n\n\nreveal\nR8\n(1,0,0,0)\nZERO, ONE_MINUS_SRC_COLOR\na\n\n\n\n这两个附件的精度都不需要太高。\nGLuint accum, reveal;GLuint accum, reveal;glGenTextures(1, &amp;accum);glBindTexture(GL_TEXTURE_2D, accum);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, W, H, 0, GL_RGBA, GL_HALF_FLOAT, nullptr);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glGenTextures(1, &amp;reveal);glBindTexture(GL_TEXTURE_2D, reveal);glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, W, H, 0, GL_RED, GL_FLOAT, nullptr);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n将附件绑定到帧缓冲:\nglBindFramebuffer(GL_FRAMEBUFFER, fbo);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, accum, 0);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, reveal, 0);const GLenum attachments[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };glDrawBuffers(2, attachments);\n渲染不透明物体\n在这个例子中，直接绑定默认帧缓冲渲染就可以了。\nwhile (!glfwWindowShouldClose(window)) {    glBindFramebuffer(GL_FRAMEBUFFER, 0);    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    glClear(GL_COLOR_BUFFER_BIT);    glDisable(GL_BLEND);    glUseProgram(homo);    glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 14);    ...}\n渲染透明物体\n两个附件的混合函数不同，需要用glBlendFunci为它们分别配置。\n注意，清除附件的颜色不一样。\nwhile (!glfwWindowShouldClose(window)) {    ...    glBindFramebuffer(GL_FRAMEBUFFER, fbo);    glClearBufferfv(GL_COLOR, 0, zero); // {0,0,0,0}    glClearBufferfv(GL_COLOR, 1, one); // {1,1,1,1}    glEnable(GL_BLEND);    glBlendFunci(0, GL_ONE, GL_ONE); // accumulation    glBlendFunci(1, GL_ZERO, GL_ONE_MINUS_SRC_COLOR); // reveal    glBlendEquation(GL_FUNC_ADD);    glUseProgram(circle);    glUniform1f(glGetUniformLocation(circle, \"t\"), (float)glfwGetTime() * .5f);    glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 6);    ...}\ncircle_fsh:\n#version 410 corein vec2 fragUV;in vec4 fragCol;layout (location = 0) out vec4 accum;layout (location = 1) out float reveal;void main() {    if (length(fragUV) &gt; 0.8) discard;    // weight function    float weight = clamp(pow(min(1.0, fragCol.a * 10.0) + 0.01, 3.0) * 1e8 *                          pow(1.0 - gl_FragCoord.z * 0.9, 3.0), 1e-2, 3e3);    // store pixel color accumulation    accum = vec4(fragCol.rgb * fragCol.a, fragCol.a) * weight;    // store pixel revealage threshold    reveal = fragCol.a;}\n叠加\n经过以上的步骤，我们的任务只完成了一半。接下来是叠加。\n首先是着色器。\ncomposite_vsh:\n#version 410 corelayout (location = 0) in vec2 pos;void main() {    gl_Position = vec4(pos * 2, 0, 1);}\ncomposite_fsh:\n#version 410 core// shader outputsout vec4 frag;// color accumulation bufferuniform sampler2D accum;// revealage threshold bufferuniform sampler2D reveal;// epsilon numberconst float EPSILON = 0.00001f;// calculate floating point numbers equality accuratelybool isApproximatelyEqual(float a, float b) {    return abs(a - b) &lt;= (abs(a) &lt; abs(b) ? abs(b) : abs(a)) * EPSILON;}// get the max value between three valuesfloat max3(vec3 v) {    return max(max(v.x, v.y), v.z);}void main() {    // fragment coordination    ivec2 coords = ivec2(gl_FragCoord.xy);    // fragment revealage    float revealage = texelFetch(reveal, coords, 0).r;    // save the blending and color texture fetch cost if there is not a transparent fragment    if (isApproximatelyEqual(revealage, 1.0f)) discard;    // fragment color    vec4 accumulation = texelFetch(accum, coords, 0);    // suppress overflow    if (isinf(max3(abs(accumulation.rgb))))        accumulation.rgb = vec3(accumulation.a);    // prevent floating point precision bug    vec3 average_color = accumulation.rgb / max(accumulation.a, EPSILON);    // blend pixels    frag = vec4(average_color, 1.0f - revealage);}\naverage_color几乎就是原来的颜色，而revealage决定这个颜色的可见性。像上面这样处理，可以保证程序在一些特殊的情况也能正常渲染。\n编译以及绑定纹理:\nGLuint composite = createShader(composite_vsh, composite_fsh);glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, accum);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, reveal);glUseProgram(composite);glUniform1i(glGetUniformLocation(composite, \"accum\"), 0);glUniform1i(glGetUniformLocation(composite, \"reveal\"), 1);\n最后进行叠加渲染:\nwhile (!glfwWindowShouldClose(window)) {    ...    glBindFramebuffer(GL_FRAMEBUFFER, 0);    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);    glUseProgram(composite);    glDrawArrays(GL_TRIANGLES, 0, 6);    glfwSwapBuffers(window);    glfwPollEvents();}\n你将看到如下效果:\n完整代码，你也可以在这里找到:\n#include &lt;iostream&gt;#include &lt;cassert&gt;#include \"glad/glad.h\"#include \"GLFW/glfw3.h\"constexpr int W = 800, H = 500;constexpr float vert[] = { -.5,-.5, .5,.5, .5,-.5, -.5,.5, .5,.5, -.5,-.5 };constexpr float zero[]{0,0,0,0}, one[]{1,1,1,1};float proj[4*4]{}, _init_matrix = ([]{ // NOLINT(*-reserved-identifier)    float aspect = (float)W / (float)H;    float tanHalfFov = std::tan(.5f); // tan(pi/3/2)    float near = 0.1f, far = 100.0f;    proj[0] = 1.0f / (aspect * tanHalfFov);    proj[5] = 1.0f / tanHalfFov;    proj[10] = (far + near) / (near - far);    proj[11] =-1.0f;    proj[14] = (2.0f * far * near) / (near - far);}(), 0.f);GLFWwindow* window;constexpr auto circle_vsh = R\"(#version 410 corelayout (location = 0) in vec2 pos;out vec2 fragUV;out vec4 fragCol;uniform float t;uniform mat4 proj;const vec4 colors[] = vec4[](    vec4(.06f, .93f, .8f, .5f),    vec4(1.f, .68f, .2f, .5f),    vec4(.37f, .83f, .09f, .5f),    vec4(.87f, .93f, .2f, .5f),    vec4(1.f, .67, .47f, .5f),    vec4(1.f, .37f, .4f, .5f));void main() {    fragUV = pos * 2;    fragCol = colors[gl_InstanceID];    vec4 p = vec4(pos.x - sin(t + gl_InstanceID), pos.y, -3 - cos(t + gl_InstanceID), 1);    gl_Position = proj * p;})\", circle_fsh = R\"(#version 410 corein vec2 fragUV;in vec4 fragCol;layout (location = 0) out vec4 accum;layout (location = 1) out float reveal;void main() {    if (length(fragUV) &gt; 0.8) discard;    float weight = clamp(pow(min(1.0, fragCol.a * 10.0) + 0.01, 3.0) * 1e8 *                         pow(1.0 - gl_FragCoord.z * 0.9, 3.0), 1e-2, 3e3);    accum = vec4(fragCol.rgb * fragCol.a, fragCol.a) * weight;    reveal = fragCol.a;})\";constexpr auto homo_vsh = R\"(#version 410 corelayout (location = 0) in vec2 pos;vec2 scale[] = vec2[](    vec2(2./25., 1),    vec2(2./25., 1),    vec2(2./25., 3./5.), vec2(2./25., 1./5.), vec2(2./25., 1),    vec2(6./25., 1./5.), vec2(2./25., 1./5.), vec2(6./25., 1./5.), vec2(2./25., 1./5.), vec2(6./25., 1./5.),    vec2(2./25., 1),    vec2(2./25., 3./5.), vec2(2./25., 1./5.), vec2(2./25., 1));vec2 offset[] = vec2[](    vec2(-16./25., 0),    vec2(-12./25., 0),    vec2(-8./25., 1./5.), vec2(-6./25., 0), vec2(-4./25., 0),    vec2(2./25., 2./5.), vec2(0, 1./5.), vec2(2./25., 0), vec2(4./25., -1./5.), vec2(2./25., -2./5.),    vec2(8./25., 0),    vec2(12./25., 1./5.), vec2(14./25., 0), vec2(16./25., 0));void main() {    gl_Position = vec4(pos * scale[gl_InstanceID] + offset[gl_InstanceID], 0, 1);})\", homo_fsh = R\"(#version 410 coreout vec4 color;void main() { color = vec4(1, 0.333, 0, 1); })\";constexpr auto composite_vsh = R\"(#version 410 corelayout (location = 0) in vec2 pos;void main() { gl_Position = vec4(pos * 2, 0, 1); })\", composite_fsh = R\"(#version 410 coreout vec4 frag;uniform sampler2D accum;uniform sampler2D reveal;const float EPSILON = 0.00001f;bool isApproximatelyEqual(float a, float b) {    return abs(a - b) &lt;= (abs(a) &lt; abs(b) ? abs(b) : abs(a)) * EPSILON;}float max3(vec3 v) { return max(max(v.x, v.y), v.z); }void main() {    ivec2 coords = ivec2(gl_FragCoord.xy);    float revealage = texelFetch(reveal, coords, 0).r;    if (isApproximatelyEqual(revealage, 1.0f)) discard;    vec4 accumulation = texelFetch(accum, coords, 0);    if (isinf(max3(abs(accumulation.rgb)))) accumulation.rgb = vec3(accumulation.a);    vec3 average_color = accumulation.rgb / max(accumulation.a, EPSILON);    frag = vec4(average_color, 1.0f - revealage);})\";GLuint createShader(const char* vsh, const char* fsh) {    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vsh, nullptr);    glCompileShader(vertexShader);    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fsh, nullptr);    glCompileShader(fragmentShader);    GLuint program = glCreateProgram();    glAttachShader(program, vertexShader);    glAttachShader(program, fragmentShader);    glLinkProgram(program);    GLint success;    glGetProgramiv(program, GL_LINK_STATUS, &amp;success);    if(!success) {        GLint length;        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;length);        std::string infoLog(\"\\0\", length);        glGetProgramInfoLog(program, 512, nullptr, infoLog.data());        throw std::runtime_error(\"Failed to link shader:\\n\" + infoLog);    }    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader);    return program;}int main() {    if (glfwInit() == GLFW_FALSE)        assert(false &amp;&amp; \"failed to initialize GLFW\");    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);#ifdef __APPLE__    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    window = glfwCreateWindow(W/2, H/2, \"weighted blended\", nullptr, nullptr);#else    window = glfwCreateWindow(W, H, \"weighted blended\", nullptr, nullptr);#endif    assert(window &amp;&amp; \"failed to create window\");    glfwMakeContextCurrent(window);    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))        assert(false &amp;&amp; \"failed to initialize GLAD\");    glEnable(GL_BLEND);    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);    glViewport(0, 0, W, H);    GLuint circle = createShader(circle_vsh, circle_fsh),           homo = createShader(homo_vsh, homo_fsh),           composite = createShader(composite_vsh, composite_fsh);    glUseProgram(circle);    glUniformMatrix4fv(glGetUniformLocation(circle, \"proj\"), 1, GL_FALSE, proj);    glUseProgram(composite);    glUniform1i(glGetUniformLocation(composite, \"accum\"), 0);    glUniform1i(glGetUniformLocation(composite, \"reveal\"), 1);    GLuint vao, vbo;    glGenVertexArrays(1, &amp;vao);    glBindVertexArray(vao);    glGenBuffers(1, &amp;vbo);    glBindBuffer(GL_ARRAY_BUFFER, vbo);    glBufferData(GL_ARRAY_BUFFER, sizeof(vert), vert, GL_STATIC_DRAW);    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), nullptr);    glEnableVertexAttribArray(0);    GLuint fbo;    glGenFramebuffers(1, &amp;fbo);    glBindFramebuffer(GL_FRAMEBUFFER, fbo);    GLuint accum, reveal;    glGenTextures(1, &amp;accum);    glActiveTexture(GL_TEXTURE0);    glBindTexture(GL_TEXTURE_2D, accum);    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, W, H, 0, GL_RGBA, GL_HALF_FLOAT, nullptr);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glGenTextures(1, &amp;reveal);    glActiveTexture(GL_TEXTURE1);    glBindTexture(GL_TEXTURE_2D, reveal);    glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, W, H, 0, GL_RED, GL_FLOAT, nullptr);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, accum, 0);    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, reveal, 0);    constexpr GLenum attachments[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };    glDrawBuffers(2, attachments);    while (!glfwWindowShouldClose(window)) {        glBindFramebuffer(GL_FRAMEBUFFER, 0);        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);        glClear(GL_COLOR_BUFFER_BIT);        glDisable(GL_BLEND);        glUseProgram(homo);        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 14);        glBindFramebuffer(GL_FRAMEBUFFER, fbo);        glClearBufferfv(GL_COLOR, 0, zero); // {0,0,0,0}        glClearBufferfv(GL_COLOR, 1, one); // {1,1,1,1}        glEnable(GL_BLEND);        glBlendFunci(0, GL_ONE, GL_ONE); // accumulation        glBlendFunci(1, GL_ZERO, GL_ONE_MINUS_SRC_COLOR); // reveal        glBlendEquation(GL_FUNC_ADD);        glUseProgram(circle);        glUniform1f(glGetUniformLocation(circle, \"t\"), (float)glfwGetTime() * .5f);        glDrawArraysInstanced(GL_TRIANGLES, 0, 6, 6);        glBindFramebuffer(GL_FRAMEBUFFER, 0);        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);        glUseProgram(composite);        glDrawArrays(GL_TRIANGLES, 0, 6);        glfwSwapBuffers(window);        glfwPollEvents();    }    return 0;}\n","categories":["Graphics"],"tags":["Note"]},{"title":"狗头圈的所有结局","url":"/2024/08/22/%E7%8B%97%E5%A4%B4%E5%9C%88%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%93%E5%B1%80/","content":"\n\n普通结局\n你的作品无人问津，在圈子混乱的攀比中失去了兴趣，决定服从父母的要求好好学习\n面包结局：你加入了某某工作室，你感觉这是你离鼻子最近的一次，但你不得不听从他们的指挥，直到你的账号被封禁\nNazi结局\n老鼻子带领着他所有的面包人闪击中国统治者们，取得重大胜利，自己成为国家新的元首，把中国建设成了一个纳粹主义国家，并将自己的侵略与扩张蔓延至全世界，直到全人类都不得不服从老鼻子的统治\n画家结局\n你感觉在这个圈子混的很容易，其他人都是小孩，低能，无知，容易欺负的，不用像其他圈子那样守规矩，也不需要什么技术（对你而言）。。。怎么出货又下架了？\n混乱结局\n这个圈子没给你喘息的机会，一些人为了不可见的利益开始攻击你，讲道理是没用的，你再也不会在这个圈子留下其他作品了\n比较坏的结局\n你被封号了，但是你心有不甘仍然希望靠着狗头重现辉煌，于是你把几乎所有的时间都投入到了视频的创作，但是你的视频再也不火了，就这样你不仅荒废了学业而且在网络上也没有成就，最终现实里没有考上高中被同龄人歧视被父母赶出家门搬砖，网络上也变成了一个人人嘲笑的小丑\n或许这是乐乐的结局\n你本来就是一个成年人，发视频顶多算是你的业余爱好，因为就算你不发视频也顶多只会像其余的同龄人一样把游戏花费在打游戏上罢了，而你账号的封禁顶多只能算是让你失去了一项业余的爱好，而你的工作仍然有条不紊的进行着\n狗急了结局\n你借助混乱拿到了圈子的话语权，但这个圈子早已是一盘散沙，你没法重建帝国的辉煌，所谓的大作也没了续集，在互联网的潮水中，你成了孙吧的常客\n鼻子结局\n你用光了最后一个账号，本来你想借助面包人的账号重新回归，但你觉得这似乎配不上你的身份；你决定转移阵地，但好像别的平台并不那么待见你。你发现你变地像只过街老鼠，就和现实生活中一样\n浪潮结局\n混乱给你造成了不少的伤害，那你早已认清这个圈子的真相，所以这些你早就遇想了，你决定务实一点，做些有意义的事，毕竟朋友也陪在你身边\n劣质化结局\n已经到2022年了，当其他人都因为攀比画技并制作狗头打斗视频而封号时你仍然默默无闻地发着狗头刚诞生之初的那一类视频，你的狗头卡包系列一直都有小孩子们为你提供播放量，你只需要照着他们评论，想看的去做就好了，就这样你的视频慢慢脱离了最初的狗头小剧场，慢慢演化为了网上的那些圈钱垃圾骗小孩的动画主播\nB站结局\n你认为狗头的失败是因为抖音这个平台的问题，于是你前往了噼里啪啦，你惊喜地发现这里的人比你想象的要友好，但是对你视频有兴趣的人数也并不多，最后狗头并没有如花粉刚到B站时那般狼狈，但最后也只是成为了一个平凡的小圈子罢了，但你感觉这一切其实也就足够了，至少比在抖音提心吊胆的害怕封号强多了\n","categories":["Useless"]}]