[{"title":"从投影和观察矩阵提取视锥体","url":"/2024/03/02/%E4%BB%8E%E6%8A%95%E5%BD%B1%E5%92%8C%E8%A7%82%E5%AF%9F%E7%9F%A9%E9%98%B5%E6%8F%90%E5%8F%96%E8%A7%86%E9%94%A5%E4%BD%93/","content":"视锥体\n首先我不知道\"视锥体\"这个名字是否正确，但接下来我会使用这个称呼\n\n如图，视锥体是一个六面体。如果一个物体在视锥体内部，那么他就有可能显示在屏幕上。如果我们能够求出当前摄像机的视锥体，并对场景中所有物体的包围盒求交，那么我们就能过滤掉那些绝不可能显示在屏幕上的物体，从而达到减少渲染开支的目的。这其实就是可见性裁切(Visibility\nCulling)。\n想要进行上述操作，一个正确的在世界坐标下视锥体是必须的，如何求出这个视锥体，现在有两个方案:\n1. 根据相机投影矩阵参数生成，然后对原始视锥体进行变换\n2. 通过 projection-view 矩阵直接提取\n前者虽然简单，但是变换6个面还是有一点开销，所以我们选择后者，也就是本篇文章讨论的内容。\n平面方程\n先让我们回顾一下平面方程:\n\n其中平面的法向量其实就是(A, B, C)，即:\n\n而D可以视作原点到平面的距离。相信大家能看出，等式左边其实就是计算一个点到平面的距离，那我们不妨定义一个距离函数:\n\n当函数值为0时，那就意味着点P在平面上。\n\n注意: 本文接下来会直接用距离函数来表示一个平面\n\n提取视锥体\n假设有一个矩阵，时投影(projection)和观察(view)矩阵的乘积\n\n我们将一个点与之相乘\n\n接下来就会被变换到剪裁空间(Clip\nSpace)，如果对其进行透视除法(即: )，就可以将其转换到NDC(Normalized Device\nCoordinates)\n\n\n剪裁空间和NDC以vulkan中为例，下文计算也以此为准\n\n我们直接看剪裁空间的，如果可见，那么其一定满足如下条件:\n\n让我们关注的情况，先用替换，也如此\n\n只看 \n，我们不难发现这就能表示一个平面:\n\n但是我们需要平面的法向量是单位向量的，所以还需要归一化:\n\n我们用归一化后的来表示这个平面:\n\n\n注意：这里是两个四维向量相乘，平面方程的四个系数其实就是的四个分量\n\n这时只有点P在平面上方时，P才可能可见。\n对于  ，我们也如法炮制:\n\n同样也用一个平面来表示:\n\n依然只有点P在平面上方时，P才可能可见。\n我们不难举一反三写出所有六个面的方程:\n\n\n注意vulkan中NDC顶部是-1\n\n实现代码\n最后附上可能的c++实现代码。\nstd::array&lt;vec4, 6&gt; CreateViewingFrustumFromMatrix(const mat4&amp; mat, float x_left, float x_right, float y_top, float y_bottom, float z_near, float z_far) {    std::array&lt;vec4, 6&gt; f;    auto&amp; plane_right   = f[0];    auto&amp; plane_left    = f[1];    auto&amp; plane_top     = f[2];    auto&amp; plane_bottom  = f[3];    auto&amp; plane_near    = f[4];    auto&amp; plane_far     = f[5];#define NORMALIZE(x) do { \\    float rlen = 1.f / std::sqrtf(vec3(x).length_squared()); \\    x *= rlen; \\} while(0)    auto mat_column = mat.transposed();        plane_right = mat_column[3] * x_right - mat_column[0];    NORMALIZE(plane_right);    plane_left = mat_column[0] - mat_column[3] * x_left;    NORMALIZE(plane_left);    plane_top = mat_column[3] * y_top - mat_column[1];    NORMALIZE(plane_top);    plane_bottom = mat_column[1] - mat_column[3] * y_bottom;    NORMALIZE(plane_bottom);    plane_near = mat_column[2] - mat_column[3] * z_near;    NORMALIZE(plane_near);    plane_far = mat_column[3] * z_far - mat_column[2];    NORMALIZE(plane_far);    return f;    #undef NORMALIZE}\n引用\nFast\nExtraction of Viewing Frustum Planes from the WorldView -\nProjectionMatrix\n","categories":["Computer Graphics"],"tags":["Note"]},{"title":"Viewing world at 60Hz","url":"/2024/02/24/Viewing-world-at-60Hz/","content":"Introduction\n首先简单说一下这个博客的名字，Viewing world at\n60Hz(60Hz看世界)\n为啥叫这个名呢\n你想，宇宙运转的那么快，上帝拥有几乎无限的算力，世界反应一帧可以说不用时间\n而人类呢，反应迟钝，一秒顶多思考60次\n但尽管如此，宇宙那神秘的面纱在人类面前仍然触手可及\n那么，这篇博客的用意也很明显\n用这个时代给予的特权，用仅仅60Hz思维频率\n观察宇宙，了解宇宙，感受宇宙\n\n宇宙最不可理解之处，就在于它是可理解的 --Albert Einstein\n\nWhat can I say\n不管怎么说，这总归是一个学术博客，我会在这发布一些学术文章\n可能包含:\n- C++\n- Computer Graphics\n- ... // I haven't decided yet.\n可能会开放一个图书角，放一些相关书籍\n\n个人发电，不定时更新\n\n不善言辞，就不多说了，也不想就第一篇文章，还要改好几次\nTo Be Continued\n最后放一张图片，是别人为我做的，随便放的没有什么别的意思\n","categories":["Useless"],"tags":["null"]},{"title":"二叉树浅谈","url":"/2024/03/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B5%85%E8%B0%88/","content":"前言\n这几天突发奇想研究了一下二叉树，发现这东西确实有些能讲的。这篇算是一个笔记，也算记录一下自己的一些疑惑。\n树绝对是一种非常常用的数据结构，但c++stl并没有提供现成的容器，每次都需要自己实现。所以这篇文章也会记录一下，我在实践中遇到的问题。\n树\n树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n它具有以下的特点:\n- 每个节点有零个或多个子节点；\n- 没有父节点的节点称为根节点；\n- 每一个非根节点有且只有一个父节点；\n-\n除了根节点外，每个子节点可以分为多个不相交的子树(Subtree)\n补充性质:\n- 根节点到达每个节点的路径是唯一的\n\n树的概念不再过多赘述，更多信息请看引用，这里再强调一些重点:\n- 度: 子节点的个数\n- 深度: 根到此节点的经过的连接数\n- 树的高度: 最大深度+1\n- 根节点: 没有父亲的节点\n- 中间节点: 有父亲有孩子的节点\n- 叶子节点: 没有孩子的节点\n二叉树\n二叉树(Binary Tree)最直接的定义: 度为2的树\n二叉树作为一种特殊的树，拥有树的所有性质。\n特殊的二叉树\n空二叉树(Empty Binary Tree)\n没有节点的二叉树。空二叉树的高度是0。\n满二叉树(Full Binary Tree)\n除了叶子节点都有两个孩子。任一节点的子树都是满二叉树。\n只有根节点或着空二叉树也是满二叉树。\n性质:\n- 如果层序遍历这棵树，那么n号节点的两个孩子必然是(2n+1)和(2n+2)\n- 高度为k的满二叉树共有(2^k-1)个节点\n完全二叉树(Completed Binary\nTree)\n一棵深度为k的有n个结点的二叉树，按层序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。\n完全二叉树由于其特殊的性质，所以可以直接存储在数组中。stl中的std::make_heap也是这个原理。\n平衡二叉树(Balanced Binary\nTree)\n任一节点子树的深度差不超过1。\n平衡二叉树可以提高搜索效率。\n完全二叉树是平衡二叉树。\n二叉搜索树(Binary Search\nTree)\n二叉搜索树中每个节点都满足以下性质:\n- 所有左子树的节点的值都小于该节点的值；\n- 所有右子树的节点的值都大于该节点的值。\n二叉树的遍历\n前序遍历(Preorder Traversal)\n是一种深度优先遍历方法，会从根节点开始，然后遍历左子树，其次右子树。即遵循\"根-左-右\"原则。\n中序遍历(Inorder Traversal)\n首先递归地访问左子树，然后访问根节点，最后访问右子树。即遵循\"左-根-右\"原则。对于二叉搜索树，中序遍历的结果是按照升序排列的。\n后序遍历(Postorder Traversal)\n后序遍历先递归地访问左子树，然后访问右子树，最后访问根节点。即遵循\"左-右-根\"原则。这种遍历方法常用于树的删除操作。\n层序遍历(Level Order\nTraversal)\n是一种广度优先遍历方法，从根节点开始，逐层访问树中的每个节点。\n代码\n对于前三者来说，它们都是基于递归的，所以不可能做进迭代器中。在代码上它们只有访问位置的区别。\n而层序遍历是基于队列的。\nenum Order {    preorder,    inorder,    postorder,    level};void TraversalTree(Node* root, Order order) {    if (root == nullptr) return;    switch (order) {    case preorder: printf(\"%d \", root-&gt;val);  // 访问节点        TraversalTree(root-&gt;left, order);  // 递归访问左子树    case inorder: printf(\"%d \", root-&gt;val);  // 访问节点        TraversalTree(root-&gt;right, order);  // 递归访问右子树    case postorder: printf(\"%d \", root-&gt;val);  // 访问节点    case level: {        std::queue&lt;Node*&gt; que;        que.emplace(root);        while (!que.empty()) {            printf(\"%d \", root-&gt;val); // 访问节点            if (que.front()-&gt;left) que.emplace(que.front()-&gt;left); // 左节点入队            if (que.front()-&gt;right) que.emplace(que.front()-&gt;right); // 右节点入队            que.pop(); // 当前节点出队        }    }    }}\n二叉树的存储\n接下来是本文的重点。\n二叉树的存储基本可以分为两类:\n- 多重链表\n- 数组\n多重链表\n顾名思义，在一个节点中能指向多个节点的链表是多重链表。\n一个简单的节点结构可以这么写:\ntemplate &lt;class dtype&gt;struct Node {    dtype data;    Node&lt;dtype&gt;* parent;    Node&lt;dtype&gt;* left, right;}Node&lt;int&gt; root;\n它面临的问题十分明显:\n- 难以遍历\n- 无法随机读取\n- 需要额外管理内存\n作为链表，内存分配开销大本身也就是一个问题。\n由于不能随机读取，我一般使用时都会用一个哈希表来映射节点以换取速度。\n至于内存管理，简单直接的方法就是使用智能指针。当然你也可以选择用引用来构建一棵树，让别的容器来管理。\n遍历是最大的问题，如果想开放迭代器，那就只能在迭代器里实现一个BFS。那么迭代器的体积会变得多大就不用说了。\n工业上可能会用内存池之类的技术来解决上述问题，但日常使用不可能有这么大的复杂度。\n优点:\n- 直观\n- 增删移动节点容易\n数组\n在上面说了完全二叉树是可以直接存储在数组里的。但这里是将任意二叉树存储在数组中。\n首先说这么做的优点:\n- 利于遍历\n- 不需要管理内存\n基本就像这样:\nstruct Node {    int data;    size_t parent;    size_t left, right;};std::vector&lt;Node&gt; tree;\n这样看起来最大的区别就是多了一个数组。但实际上，如果你维护这个数组，使它按照树的遍历顺序排列，那么你通过直接遍历数组，就可以遍历树了。\n这里数组也可以是别的容器。但既然是为了遍历，那么也没用什么结构比数组遍历还要快。\n当然他也有缺点:\n- 增删移动慢的要命\n- 如果内存分配很保守，就会产生浪费\n这种方法适用于一次性不维护的树，因为不会有增删移动。否则还是使用多重链表。\n引用\nC/C++ 数据结构\n树】探索C/C++中的二叉树：从理论到实践\n详解二叉树的存储王道版（C++/C）\n树（数据结构名词）_百度百科\n","categories":["C++"],"tags":["Note"]},{"title":"编写一个JSON解析器「C++」","url":"/2024/06/21/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAJson%E8%A7%A3%E6%9E%90%E5%99%A8/","content":"目录\n\n\n简介\n\n\n什么是JSON\n\n\n1.1 JSON的基本数据类型\n1.2 JSON中的token\n\n\n封装一个JSON容器\n\n\n2.1 数据存储\n2.2 包装\n\n\n实现JSON解析器\n\n\n3.1 JsonScanner\n3.2 JsonParser\n\n\n简介\n\n本站主打“一文通”\n\n之前打磨了一下自己的工具库，这个JSON解析器算少数几个还能用的，索性重写了一下。现在自我感觉良好，所以分享一下。\n什么是JSON\nJSON作为一种轻量级资料交换格式，具有易于阅读和处理的优势。\nJSON的基本数据类型\n\n数值: 不区分整数与浮点数，用双精度浮点数表示所有数值。\n字符串:\n以双引号\"\"括起来的零个或多个Unicode码位。支持反斜杠开始的转义字符序列。\n布尔值：表示为true或者false。\n数组：有序的零个或者多个值。每个值可以为任意类型。数组使用方括号[]包裹。多个数组元素之间用逗号,分隔，形如：[value, value]。\n对象：若干无序的“键-值对”(key-value\npairs)，其中键只能是字符串。建议但不强制要求对象中的键是独一无二的。对象以花括号{}包裹。多个键-值对之间使用逗号,分隔。键与值之间用冒号:分隔。\n空值：值写为null。\n\nJSON中的token\n\n6种标点符号: {} [] ,\n:\n3种字面量: false true\nnull\n字符串\n数值\n\n除此之外，四个特定字符被认为是空白符：空格符、水平制表符、回车符、换行符。JSON标准不允许有字节序掩码，不提供注释的句法。\n封装一个JSON容器\n了解了JSON的基本语法后就可以着手实现解析器了。让我们先从JSON容器开始。\n数据存储\n首先明确我们存储JSON数据的底层类型。\nclass Json;using JsonObject = std::unordered_map&lt;std::string, Json&gt;;using JsonArray = std::vector&lt;Json&gt;;using JsonString = std::string;using JsonNumber = double;using JsonBoolean = bool;\n因为一个JSON元素可能为这6个基本数据类型和空值中的任意一个，所以我们需要一个多态类型存储。可以用std::variant来实现这个多态，但我选择虚拟类。\nstruct JsonElementBase {    virtual ~JsonElementBase() = default;    [[nodiscard]] virtual JsonElementBase* clone() const = 0;    // ...    // 读取和判断值的一些方法    [[nodiscard]] virtual std::string dumps() const = 0; // 将数据转化为JSON文本    [[nodiscard]] virtual JsonType type() const = 0; // 获取类型};\n为了判断一个JSON元素中到底存储的是什么类型的值，我们需要一个包含6个基本数据类型的枚举。\n这里我引入了X-MACRO来简化代码，这个在后面作用比较大。\n#define JSON_TYPE_NON_NULL(f) \\    f(Object) \\    f(Array) \\    f(String) \\    f(Number) \\    f(Boolean)#define JSON_TYPE(f) \\    JSON_TYPE_NON_NULL(f) \\    f(Null)enum class JsonType {#define g(x) x,    JSON_TYPE(g)#undef g};\n接下来可以写完JSON元素的剩余几个接口。\n#define g(x) virtual Json##x&amp; as##x() = 0;    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual const Json##x&amp; as##x() const = 0;    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual bool is##x() const = 0;    JSON_TYPE(g);#undef g\n其中包括:\n- asXXX()(两个版本): 读取实际存储的值。\n- isXXX(): 判断存储的值是否为某类型。\n接下来为各各数据类型创建类，以及一种默认情况。\n#define ERROR(s) do{throw std::logic_error(s);}while(0)struct JsonElement : public JsonElementBase {#define g(x) virtual Json##x&amp; as##x() {ERROR(\"Call 'asXXX()' with wrong type!\");}    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual const Json##x&amp; as##x() const {ERROR(\"Call 'asXXX()' with wrong type!\");}    JSON_TYPE_NON_NULL(g)#undef g#define g(x) virtual bool is##x() const {return false;}    JSON_TYPE(g);#undef g};\n默认情况下asXXX()会抛异常，isXXX()返回false。接下来只要覆盖特定功能函数就行了。\n后面的代码比较重复，优先写宏。\n#define BEGIN_ELEMENT(n) \\    struct JsonElement##n : public JsonElement { \\        Json##n val; \\        JsonElement##n() = default; \\        JsonElement##n(const Json##n&amp; val) : val(val) {} \\        JsonElement##n(Json##n&amp;&amp; val) : val(std::move(val)) {} \\        JsonElementBase* clone() const override {return new JsonElement##n(val);} \\        Json##n&amp; as##n() override {return val;} \\        const Json##n&amp; as##n() const override {return val;} \\        bool is##n() const override {return true;} \\        JsonType type() const override {return JsonType:: n;}#define END_ELEMENT() };\n每个类型实现如下:\nBEGIN_ELEMENT(Object)    std::string dumps() const override {        std::stringstream ss;        ss &lt;&lt; val;        return ss.str();    }END_ELEMENT() // ObjectBEGIN_ELEMENT(Array)    virtual std::string dumps() const override {        std::stringstream ss;        ss &lt;&lt; val;        return ss.str();    }END_ELEMENT() // ArrayBEGIN_ELEMENT(String)    std::string dumps() const override {        std::stringstream ss;        ss &lt;&lt; std::quoted(val);        return ss.str();    }END_ELEMENT() // StringBEGIN_ELEMENT(Number)    std::string dumps() const override {        auto s = std::to_string(val);        if (s.find('.') &lt; s.size()) {            auto n = s.find_last_not_of('0');            s.erase(s[n-1] == '.' ? n-1 : n);        }        return s;    }END_ELEMENT() // NumberBEGIN_ELEMENT(Boolean)    std::string dumps() const override {        return val ? \"true\" : \"false\";    }END_ELEMENT() // Booleanstruct JsonElementNull : public JsonElement {    JsonElementNull() = default;    JsonElementBase* clone() const override {return new JsonElementNull();}    bool isNull() const override {return true;}    JsonType type() const override {return JsonType::Null;}    std::string dumps() const override {return \"null\";}}; // Null\n除了JSON文本转换没什么特别要写的。不过null比较特殊，因为他没有数据成员。\n包装\n弄完这些就可以包装为最终的JSON容器了。\n看起来像是这样:\nclass Json {public:    Json() : element(std::make_unique&lt;JsonElementNull&gt;()) {}    Json(const Json&amp; o) : element(o.element-&gt;clone());    Json(Json&amp;&amp; o) noexcept : element(std::move(o.element));    Json&amp; operator=(const Json&amp; o) {        element.reset(o.element-&gt;clone());    }    Json&amp; operator=(Json&amp;&amp; o) noexcept {        element = std:move(o.element);    }#define g(x) Json(const Json##x&amp; v);    JSON_TYPE_NON_NULL(g)#undef g#define g(x) Json(Json##x&amp;&amp; v);    JSON_TYPE_NON_NULL(g)#undef g#define g(x) Json##x&amp; as##x();    JSON_TYPE_NON_NULL(g)#undef g#define g(x) const Json##x&amp; as##x() const;    JSON_TYPE_NON_NULL(g)#undef g#define g(x) bool is##x() const;    JSON_TYPE(g);#undef g#define g(x) static Json Make##x() {return Json(Json##x{});}    JSON_TYPE_NON_NULL(g)    static Json MakeNull() {return Json{};}#undef g    std::string dumps() const;    JsonType type() const;    Json&amp; operator[](const std::string&amp; k) {        assert(isObject() &amp;&amp; \"Element isn't an object!\");        return asObject()[k];    }    const Json&amp; operator[](const std::string&amp; k) const {        assert(isObject() &amp;&amp; \"Element isn't an object!\");        return asObject().at(k);    }    Json&amp; operator[](size_t n) {        assert(isArray() &amp;&amp; \"Element isn't an array!\");        return asArray()[n];    }    const Json&amp; operator[](size_t n) const {        assert(isArray() &amp;&amp; \"Element isn't an array!\");        return asArray()[n];    }    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Json&amp; json) {        return os &lt;&lt; json-&gt;dumps();    }    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const JsonObject&amp; object) {        os &lt;&lt; \"{\";        for (auto iter = object.begin(); iter != object.end(); iter++) {            os &lt;&lt; '\\\"' &lt;&lt; iter-&gt;first &lt;&lt; '\\\"' &lt;&lt; \": \" &lt;&lt; iter-&gt;second;            if (std::next(iter) != object.end()) {                os &lt;&lt; \", \";            }        }        os &lt;&lt; \"}\";        return os;    }    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const JsonArray&amp; array) {        os &lt;&lt; \"[\";        for (size_t i = 0; i &lt; array.size(); i++) {            os &lt;&lt; array[i];            if (i != array.size() - 1) {                os &lt;&lt; \", \";            }        }        os &lt;&lt; \"]\";        return os;    }private:    std::unique_ptr&lt;JsonElementBase&gt; element;};\n上面的代码省略了部分工具函数的实现。\n实现JSON解析器\n然后是JSON的解析。\nJsonScanner\n我们首先需要一个工具类来识别JSON的token。\n它应该包含如下功能:\n- Scan(): 返回一个token\n- Rollback(): 回到上一个token\n- GetStringValue(): 返回读到的字符串token的值\n- GetNumberValue(): 返回读到的数字token的值\n我们需要一个枚举来区分token:\nenum class JsonTokenType {    BEGIN_OBJECT, // {    END_OBJECT, // }    BEGIN_ARRAY, // [    END_ARRAY, // ]    VALUE_SEPARATOR, // ,    NAME_SEPARATOR, // :    VALUE_STRING, // \"string\"    VALUE_NUMBER, // 1, 2, ...    LITERAL_TRUE, // true    LITERAL_FALSE, // false    LITERAL_NULL, // null    END_OF_SOURCE // EOF};\n那么我们就可以开始编写这个类。\nclass JsonScanner {public:    JsonScanner() = default;    JsonScanner(const std::string&amp; source) : src(source) {}    JsonTokenType Scan() {        if (IsAtEnd()) {            return JsonTokenType::END_OF_SOURCE;        }        prev_pos = current;        char c = Advance();        switch (c) {            case '{':                return JsonTokenType::BEGIN_OBJECT;            case '}':                return JsonTokenType::END_OBJECT;            case '[':                return JsonTokenType::BEGIN_ARRAY;            case ']':                return JsonTokenType::END_ARRAY;            case ':':                return JsonTokenType::NAME_SEPARATOR;            case ',':                return JsonTokenType::VALUE_SEPARATOR;            case 't':                ScanTrue();                return JsonTokenType::LITERAL_TRUE;            case 'f':                ScanFlase();                return JsonTokenType::LITERAL_FALSE;            case 'n':                ScanNull();                return JsonTokenType::LITERAL_NULL;            case '\"':                ScanString();                return JsonTokenType::VALUE_STRING;            default:                if (std::isdigit(c) || c == '+' || c == '-') {                    ScanNumber();                    return JsonTokenType::VALUE_NUMBER;                }                if (std::isspace(c)) {                    return Scan();                }                ERROR(std::string(\"Unsupported Token: \") + c);                break;        }    }    void Rollback() {        current = prev_pos;    }    JsonString GetStringValue() {        return value_string;    }    JsonNumber GetNumberValue() {        return value_number;    }private:    std::string src; // json source    size_t current = 0; // current handling pos    size_t prev_pos = 0; // previous handling pos    JsonString value_string;    JsonNumber value_number;    // ...    // 其他成员函数};\n基本逻辑就是看到什么就读什么，我们只需要识别和跳过字符。\n成员函数:\nbool IsAtEnd() {    return current &gt;= src.size();}char Advance() {    if (current &lt; src.size()) return src[current++];    else return 0;}char Peek() {    if (current &lt; src.size()) return src[current];    else return 0;}char PeekNext() {    if (current &lt; src.size()) return src[current + 1];    else return 0;}void ScanTrue() {    if (src.compare(current, 3, \"rue\") == 0) {        current += 3;    } else {        ERROR(\"Scan 'true' error\");    }}void ScanFlase() {    if (src.compare(current, 4, \"alse\") == 0) {        current += 4;    } else {        ERROR(\"Scan 'false' error\");    }}void ScanNull() {    if (src.compare(current, 3, \"ull\") == 0) {        current += 3;    } else {        ERROR(\"Scan 'null' error\");    }}void ScanNumber() {    auto pos = current - 1;    bool dotflag = true, eflag = true;    while (std::isdigit(Peek()) ||            (Peek() == '.' &amp;&amp; dotflag) ||            ((Peek() == 'e' || Peek() == 'E') &amp;&amp; eflag)) {        if (Peek() == '.') {            dotflag = false;        } else if (Peek() == 'e' || Peek() == 'E') {            eflag = false;            Advance(); // '+' and '-' may follow 'e'        }        Advance();    }    value_number = std::stof(src.substr(pos, current - pos));}void ScanString() {    std::string r;    char c;    while((c = Advance()) != '\"' &amp;&amp; !IsAtEnd()) {        if (c == '\\\\') {            switch (c = Advance()) {                case '\\\\': r += '\\\\'; break;                case 'n': r += '\\n'; break;                case 't': r += '\\t'; break;                case 'r': r += '\\r'; break;                case 'b': r += '\\b';  break;                case 'f': r += '\\f'; break;                case 'a': r += '\\a'; break;                case 'v': r += '\\v'; break;                default: r += c; break;            }        } else {            r += c;        }    }    if (IsAtEnd()) {        ERROR(\"Invalid string: missing closing quote!\");    }    value_string = r;}\n字符串会麻烦一点，因为要处理转意符。\nJsonParser\n最后是这个用于解析的类。通过一个Parse()函数返回解析的Json实例。\nclass JsonParser {public:    JsonParser() = default;    JsonParser(const std::string&amp; str) : scanner(str) {}    JsonParser(const JsonScanner&amp; scanner) : scanner(scanner) {}    Json Parse() {        auto token_type = scanner.Scan();        switch (token_type) {            case JsonTokenType::BEGIN_OBJECT:                return {ParseObject()};            case JsonTokenType::BEGIN_ARRAY:                return {ParseArray()};            case JsonTokenType::VALUE_STRING: {                const auto&amp; str = scanner.GetStringValue();                return {str};            }            case JsonTokenType::VALUE_NUMBER: {                auto num = scanner.GetNumberValue();                return {num};            }            case JsonTokenType::LITERAL_TRUE:                return {true};            case JsonTokenType::LITERAL_FALSE:                return {false};            case JsonTokenType::LITERAL_NULL:            case JsonTokenType::END_OF_SOURCE:            default:                return {};        }    }private:    JsonScanner scanner;    JsonObject ParseObject();    JsonArray ParseArray();};\n同样的逻辑，根据token判断值，只是如果是JSON对象和数组的话就需要递归读取。\n对象需要分别读键和值。\nJsonObject ParseObject() {    JsonObject rst{};    auto next = scanner.Scan();    if (next == JsonScanner::JsonTokenType::END_OBJECT) {        return rst;    }    scanner.Rollback();    while (true) {        next = scanner.Scan();        if (next != JsonScanner::JsonTokenType::VALUE_STRING) {            ERROR(\"Key must be string!\");        }        std::string key = scanner.GetStringValue();        next = scanner.Scan();        if (next != JsonScanner::JsonTokenType::NAME_SEPARATOR) {            ERROR(\"Expected ':'!\");        }        rst.insert({key, Parse()});        next = scanner.Scan();        if (next == JsonScanner::JsonTokenType::END_OBJECT) {            break;        }        if (next != JsonScanner::JsonTokenType::VALUE_SEPARATOR) {            ERROR(\"Expected ','!\");        }    }    return rst;}\n数组一个一个读取就行。\nJsonArray ParseArray() {    JsonArray rst;    auto next = scanner.Scan();    if (next == JsonScanner::JsonTokenType::END_ARRAY) {        return rst;    }    scanner.Rollback();    while (true) {        rst.push_back(Parse());        next = scanner.Scan();        if (next == JsonScanner::JsonTokenType::END_ARRAY) {            break;        }        if (next != JsonScanner::JsonTokenType::VALUE_SEPARATOR) {            ERROR(\"Expected ','!\");        }    }    return rst;}\n别让别人吃你拉的屎。\n#undef BEGIN_ELEMENT#undef END_ELEMENT#undef ERROR#undef JSON_TYPE#undef JSON_TYPE_NON_NULL\n","categories":["C++"],"tags":["Experiment"]}]